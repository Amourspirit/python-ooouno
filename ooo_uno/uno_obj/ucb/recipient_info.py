# coding: utf-8
#
# Copyright 2022 :Barry-Thomas-Paul: Moss
#
# Licensed under the Apache License, Version 2.0 (the "License")
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http: // www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Struct Class
# this is a auto generated file generated by Cheetah
# Namespace: com.sun.star.ucb
# Libre Office Version: 7.2
import typing
if typing.TYPE_CHECKING:
    from .outgoing_message_state import OutgoingMessageState as OutgoingMessageState_c200e54
from ooo_uno.oenv import UNO_ENVIRONMENT, UNO_RUNTIME
_DYNAMIC = False
if (not typing.TYPE_CHECKING) and UNO_RUNTIME and UNO_ENVIRONMENT:
    _DYNAMIC = True
    from ooo_uno.helper import uno_helper

if typing.TYPE_CHECKING or _DYNAMIC is False:


    class RecipientInfo(object):
        """
        Struct Class

        contains all information needed to send a message using one send protocol.
        
        To send one message via two different protocols, two RecipientInfos are needed - to send one message to different users with one protocol, one RecipientInfo can be used.

        See Also:
            `API RecipientInfo <https://api.libreoffice.org/docs/idl/ref/structcom_1_1sun_1_1star_1_1ucb_1_1RecipientInfo.html>`_


        Note:
            | At runtime RecipientInfo will be an actual uno struct however can seamlessly be treated as a regualr class.
            | At design time a class is presumed. This allows for better typings.
            | RecipientInfo is a callable and can be treatead as a class and create instances.
        """

        def __init__(self, BCC: typing.Optional[str] = None, CC: typing.Optional[str] = None, Newsgroups: typing.Optional[str] = None, Password: typing.Optional[str] = None, ProtocolErrorNumber: typing.Optional[int] = None, ProtocolErrorString: typing.Optional[str] = None, ProtocolType: typing.Optional[str] = None, SendTries: typing.Optional[int] = None, Server: typing.Optional[str] = None, State: 'typing.Optional[OutgoingMessageState_c200e54]' = None, To: typing.Optional[str] = None, Username: typing.Optional[str] = None, VIMPostOfficePath: typing.Optional[str] = None):
            self._bcc = BCC
            self._cc = CC
            self._newsgroups = Newsgroups
            self._password = Password
            self._protocol_error_number = ProtocolErrorNumber
            self._protocol_error_string = ProtocolErrorString
            self._protocol_type = ProtocolType
            self._send_tries = SendTries
            self._server = Server
            self._state = State
            self._to = To
            self._username = Username
            self._vim_post_office_path = VIMPostOfficePath

        @property
        def BCC(self) -> str:
            """
            the recipient(s) of \"blind carbon copy\" (e.g.
            
            e-mail address/es).
            
            Multiple addresses are separated by commas.
            """
            return self._bcc
        
        @BCC.setter
        def BCC(self, value: str) -> None:
            self._bcc = value

        @property
        def CC(self) -> str:
            """
            the recipient(s) of a \"carbon copy\" (e.g.
            
            e-mail address/es).
            
            Multiple addresses are separated by commas.
            """
            return self._cc
        
        @CC.setter
        def CC(self, value: str) -> None:
            self._cc = value

        @property
        def Newsgroups(self) -> str:
            """
            the newsgroup(s) to which an article is be posted.
            
            Multiple addresses are separated by commas.
            """
            return self._newsgroups
        
        @Newsgroups.setter
        def Newsgroups(self, value: str) -> None:
            self._newsgroups = value

        @property
        def Password(self) -> str:
            """
            the password to be used for authorizing on the send server.
            """
            return self._password
        
        @Password.setter
        def Password(self, value: str) -> None:
            self._password = value

        @property
        def ProtocolErrorNumber(self) -> int:
            """
            the number representing the last error (generated by send server).
            """
            return self._protocol_error_number
        
        @ProtocolErrorNumber.setter
        def ProtocolErrorNumber(self, value: int) -> None:
            self._protocol_error_number = value

        @property
        def ProtocolErrorString(self) -> str:
            """
            string representing the last error (generated by send server).
            """
            return self._protocol_error_string
        
        @ProtocolErrorString.setter
        def ProtocolErrorString(self, value: str) -> None:
            self._protocol_error_string = value

        @property
        def ProtocolType(self) -> str:
            """
            the protocol to use for sending (i.e.
            
            \"NNTP\", \"SMTP\", \"VIM\").
            """
            return self._protocol_type
        
        @ProtocolType.setter
        def ProtocolType(self, value: str) -> None:
            self._protocol_type = value

        @property
        def SendTries(self) -> int:
            """
            the count of tries to send a message.
            
            This count is 1 if the message was sent with the first try and increases with every unsuccessful retry.
            """
            return self._send_tries
        
        @SendTries.setter
        def SendTries(self, value: int) -> None:
            self._send_tries = value

        @property
        def Server(self) -> str:
            """
            the name of the server to be used for sending the message.
            """
            return self._server
        
        @Server.setter
        def Server(self, value: str) -> None:
            self._server = value

        @property
        def State(self) -> 'OutgoingMessageState_c200e54':
            """
            the current state of the message.
            """
            return self._state
        
        @State.setter
        def State(self, value: 'OutgoingMessageState_c200e54') -> None:
            self._state = value

        @property
        def To(self) -> str:
            """
            the recipient(s) (e.g.
            
            e-mail address/es).
            
            Multiple addresses are separated by commas.
            """
            return self._to
        
        @To.setter
        def To(self, value: str) -> None:
            self._to = value

        @property
        def Username(self) -> str:
            """
            the user name to be used for authorizing on the send server.
            """
            return self._username
        
        @Username.setter
        def Username(self, value: str) -> None:
            self._username = value

        @property
        def VIMPostOfficePath(self) -> str:
            """
            the Post Office Path (VIM only).
            """
            return self._vim_post_office_path
        
        @VIMPostOfficePath.setter
        def VIMPostOfficePath(self, value: str) -> None:
            self._vim_post_office_path = value

if not typing.TYPE_CHECKING and _DYNAMIC:
    def _dynamic_struct() -> None:
        # Dynamically create uno struct using uno
        global RecipientInfo
        order = ('BCC', 'CC', 'Newsgroups', 'Password', 'ProtocolErrorNumber', 'ProtocolErrorString', 'ProtocolType', 'SendTries', 'Server', 'State', 'To', 'Username', 'VIMPostOfficePath')

        def _struct_init(*args, **kwargs):
            struct = uno_helper.create_uno_struct('com.sun.star.ucb.RecipientInfo')
            for i, arg in enumerate(args):
                if arg is None:
                    continue
                setattr(struct, order[i], arg)
            for k, v in kwargs.items():
                setattr(struct, k, v)
            return struct
        RecipientInfo = _struct_init

    _dynamic_struct()

__all__ = ['RecipientInfo']
