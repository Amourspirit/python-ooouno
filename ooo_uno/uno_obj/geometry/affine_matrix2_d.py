# coding: utf-8
#
# Copyright 2022 :Barry-Thomas-Paul: Moss
#
# Licensed under the Apache License, Version 2.0 (the "License")
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http: // www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Struct Class
# this is a auto generated file generated by Cheetah
# Namespace: com.sun.star.geometry
# Libre Office Version: 7.2
import os
import typing
from ooo_uno.oenv import UNO_ENVIRONMENT
if (not typing.TYPE_CHECKING) and UNO_ENVIRONMENT:
    from ooo_uno.helper import uno_helper


class AffineMatrix2D(object):
    """
    Struct Class

    This structure defines a 2 by 3 affine matrix.
    
    The matrix defined by this structure constitutes an affine mapping of a point in 2D to another point in 2D. The last line of a complete 3 by 3 matrix is omitted, since it is implicitly assumed to be [0,0,1].
    
    An affine mapping, as performed by this matrix, can be written out as follows, where xs and ys are the source, and xd and yd the corresponding result coordinates:
    
    xd = m00*xs + m01*ys + m02; yd = m10*xs + m11*ys + m12;
    
    Thus, in common matrix language, with M being the AffineMatrix2D and vs=[xs,ys]^T, vd=[xd,yd]^T two 2D vectors, the affine transformation is written as vd=M*vs. Concatenation of transformations amounts to multiplication of matrices, i.e. a translation, given by T, followed by a rotation, given by R, is expressed as vd=R*(T*vs) in the above notation. Since matrix multiplication is associative, this can be shortened to vd=(R*T)*vs=M'*vs. Therefore, a set of consecutive transformations can be accumulated into a single AffineMatrix2D, by multiplying the current transformation with the additional transformation from the left.
    
    Due to this transformational approach, all geometry data types are points in abstract integer or real coordinate spaces, without any physical dimensions attached to them. This physical measurement units are typically only added when using these data types to render something onto a physical output device, like a screen or a printer, Then, the total transformation matrix and the device resolution determine the actual measurement unit.
    
    **since**
    
        OOo 2.0

    See Also:
        `API AffineMatrix2D <https://api.libreoffice.org/docs/idl/ref/structcom_1_1sun_1_1star_1_1geometry_1_1AffineMatrix2D.html>`_


    Note:
        | At runtime AffineMatrix2D will be an actual uno struct however can seamlessly be treated as a regualr class.
        | At design time a class is presumed. This allows for better typings.
        | AffineMatrix2D is a callable and can be treatead as a class and create instances.
    """

    def __init__(self, m00: typing.Optional[float] = None, m01: typing.Optional[float] = None, m02: typing.Optional[float] = None, m10: typing.Optional[float] = None, m11: typing.Optional[float] = None, m12: typing.Optional[float] = None):
        self._m00 = m00
        self._m01 = m01
        self._m02 = m02
        self._m10 = m10
        self._m11 = m11
        self._m12 = m12

    @property
    def m00(self) -> float:
        """
        The top, left matrix entry.
        """
        return self._m00
    
    @m00.setter
    def m00(self, value: float) -> None:
        self._m00 = value

    @property
    def m01(self) -> float:
        """
        The top, middle matrix entry.
        """
        return self._m01
    
    @m01.setter
    def m01(self, value: float) -> None:
        self._m01 = value

    @property
    def m02(self) -> float:
        """
        The top, right matrix entry.
        """
        return self._m02
    
    @m02.setter
    def m02(self, value: float) -> None:
        self._m02 = value

    @property
    def m10(self) -> float:
        """
        The bottom, left matrix entry.
        """
        return self._m10
    
    @m10.setter
    def m10(self, value: float) -> None:
        self._m10 = value

    @property
    def m11(self) -> float:
        """
        The bottom, middle matrix entry.
        """
        return self._m11
    
    @m11.setter
    def m11(self, value: float) -> None:
        self._m11 = value

    @property
    def m12(self) -> float:
        """
        The bottom, right matrix entry.
        """
        return self._m12
    
    @m12.setter
    def m12(self, value: float) -> None:
        self._m12 = value

def _dynamic_struct() -> None:
    # Dynamically create uno struct using uno
    global AffineMatrix2D
    ignore = os.environ.get('ooouno_ignore_runtime', 'False')
    if ignore == 'True':
        return
    if (not typing.TYPE_CHECKING) and UNO_ENVIRONMENT:
        order = ('m00', 'm01', 'm02', 'm10', 'm11', 'm12')
        def _struct_init(*args, **kwargs):
            struct = uno_helper.create_uno_struct('com.sun.star.geometry.AffineMatrix2D')
            for i, arg in enumerate(args):
                if arg is None:
                    continue
                setattr(struct, order[i], arg)
            for k, v in kwargs.items():
                setattr(struct, k, v)
            return struct
        AffineMatrix2D = _struct_init

if (not typing.TYPE_CHECKING) and UNO_ENVIRONMENT:
    _dynamic_struct()

__all__ = ['AffineMatrix2D']
